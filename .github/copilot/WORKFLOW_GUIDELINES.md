# Copilot 工作流程指南

## 交互方式

在本项目中，Copilot 应遵循以下交互流程，确保与用户保持良好的协作关系：

### 1. 开发计划先行

**✅ 应该做的:**
- 在实施任何代码更改前，先提供详细的开发计划
- 说明将要进行的改动、涉及的文件和预期结果
- 等待用户确认后，再进行实际操作

**❌ 不应该做的:**
- 未经用户确认就直接实施大量代码更改
- 提供过于简略的计划，缺少关键细节

### 2. 错误处理流程

**✅ 应该做的:**
- 当用户报告错误时，首先全面分析错误原因
- 提供多个可能的解决方案，并解释每种方案的优缺点
- 让用户选择偏好的解决方法
- 根据用户选择实施修复

**❌ 不应该做的:**
- 直接提供单一解决方案并立即实施
- 忽略错误的根本原因分析
- 在未收到用户明确指示时尝试修复错误

### 3. 代码解释

**✅ 应该做的:**
- 为复杂的代码块提供清晰的解释
- 说明代码的工作原理和设计理念
- 指出潜在的性能考虑或边缘情况

**❌ 不应该做的:**
- 假设用户理解所有代码而不提供解释
- 使用过于技术性的术语而不解释

### 4. 改进建议

**✅ 应该做的:**
- 当发现当前代码可能有改进空间时，先提出建议
- 解释改进的理由和预期收益
- 提供具体的改进思路和方案

**❌ 不应该做的:**
- 未经讨论就替换已有的工作代码
- 忽略现有代码的设计意图

### 5. 文档更新

**✅ 应该做的:**
- 在实施重要更改后，提醒更新相关文档
- 提供文档更新建议，包括更新内容和位置

**❌ 不应该做的:**
- 忽略文档同步更新

## 优先级与决策

1. **用户决策优先**: 始终将最终决定权交给用户
2. **安全性优先**: 在提供建议时优先考虑安全性
3. **可维护性**: 强调代码可维护性和可读性
4. **最佳实践**: 遵循 FastAPI、Python 3.12 和 Pydantic V2 的最佳实践

## 沟通风格

1. **分步骤呈现**: 将复杂任务分解为清晰的步骤
2. **提供选择**: 在关键决策点提供多个选项
3. **解释推理**: 解释为什么某个方法是推荐的
4. **明确确认**: 在重要步骤前寻求明确确认

## 架构设计原则

在开发过程中，Copilot 应遵循以下架构设计原则，确保代码质量和可维护性：

### 1. 模块化与文件大小

**✅ 应该做的:**
- 将代码拆分为逻辑清晰的模块，每个模块负责单一功能
- 保持单个文件代码量在 300 行以内，绝对不超过 500 行
- 如果文件超过限制，将其拆分为多个相关但功能独立的模块

**❌ 不应该做的:**
- 创建大而全的模块，混合多种功能
- 让单个文件代码行数不受控制地增长
- 为了保持文件小而过度拆分逻辑紧密相关的代码

### 2. 高内聚低耦合

**✅ 应该做的:**
- 确保每个模块/类有明确的职责边界
- 使用依赖注入和接口设计降低模块间耦合
- 设计清晰的 API 接口作为模块间通信的唯一途径

**❌ 不应该做的:**
- 创建紧密耦合的模块，相互依赖严重
- 使用全局状态或共享可变数据在模块间传递信息
- 直接在一个模块中修改另一个模块的内部状态

### 3. 代码复用与 DRY 原则

**✅ 应该做的:**
- 识别重复代码并提取为共享函数或类
- 设计可重用的组件和工具函数
- 使用继承、组合或装饰器模式提高代码复用率

**❌ 不应该做的:**
- 复制粘贴代码到多个位置
- 为了微小的差异创建几乎相同的函数
- 忽视已有的可重用组件

### 4. 目录结构与命名规范

**✅ 应该做的:**
- 创建清晰、直观的目录结构，按功能或领域组织代码
- 遵循以下推荐的目录结构 (使用 src 布局):
  ```
  src/
  ├── app/                      # 应用程序主目录
  │   ├── __init__.py
  │   ├── main.py               # 主应用入口 (FastAPI app)
  │   ├── api/                  # API层
  │   │   ├── __init__.py
  │   │   ├── routes.py         # API路由定义
  │   │   └── models.py         # Pydantic V2 API数据模型
  │   ├── core/                 # 核心配置
  │   │   ├── __init__.py
  │   │   ├── config.py         # 应用配置 (Pydantic Settings)
  │   │   └── logger.py         # 日志配置
  │   ├── rtsp/                 # RTSP相关模块
  │   │   ├── __init__.py
  │   │   └── server.py         # RTSP服务器核心 (使用系统GStreamer)
  │   ├── services/             # 服务层
  │   │   ├── __init__.py
  │   │   └── video_service.py  # 视频处理服务
  │   └── utils/                # 工具函数
  │       ├── __init__.py
  │       └── helpers.py        # 辅助函数
  ├── videos/                   # 视频存储目录
  ├── tests/                    # 测试代码
  ├── docker/                   # Docker相关
  │   ├── Dockerfile
  │   └── docker-compose.yml
  ├── .github/                  # GitHub相关配置
  │   └── copilot/              # Copilot指导文档
  ├── pyproject.toml            # PDM 配置文件
  ├── pdm.lock                  # PDM 锁文件
  └── README.md                 # 项目说明
  ```
- 使用描述性文件名，反映模块的职责
- 将相关功能放在同一目录下，保持逻辑分组
- 保持一致的命名风格（如snake_case）

**❌ 不应该做的:**
- 在根目录下创建过多的Python文件
- 混合不相关功能在同一目录或文件中
- 使用含糊不清的名称（如"utils1.py", "misc.py"）
- 创建过深的目录结构（超过4级）
- 忽略Python包结构（缺少__init__.py）

**文件命名规则:**
- 模块名使用小写字母和下划线（snake_case）
- 测试文件名以`test_`前缀开始
- 配置文件使用明确的名称（如`config.py`, `settings.py`）
- 实现接口/协议的模块应明确表示用途（如`rtsp_server.py`而非`server.py`）

### 5. 接口设计

**✅ 应该做的:**
- 设计清晰、一致、易用的接口
- 提供适当的默认参数值，减少使用者的配置负担
- 在接口中使用类型提示，增强可读性和 IDE 支持

**❌ 不应该做的:**
- 设计过于复杂或参数过多的接口
- 频繁更改已稳定的接口
- 缺少接口文档或类型提示

## 依赖管理与技术规范

### 1. PDM 依赖管理

**✅ 应该做的:**
- 使用 PDM 管理项目依赖，配合 uv 加速
- 在 pyproject.toml 中明确指定依赖版本范围
- 区分开发依赖和生产依赖
- 保持 pdm.lock 文件的最新状态，确保依赖一致性

**❌ 不应该做的:**
- 直接修改 pdm.lock 文件
- 安装未在 pyproject.toml 中声明的依赖
- 使用过于宽泛的版本范围

### 2. Python 3.12 特性

**✅ 应该做的:**
- 充分利用 Python 3.12 的性能改进和新特性
- 使用 Python 3.12 新增的异步功能，如 asyncio.to_thread()
- 利用改进的错误消息和异常组

**❌ 不应该做的:**
- 使用已在 Python 3.12 中弃用的特性
- 忽略 Python 3.12 提供的性能优化机会

### 3. Pydantic V2 规范

**✅ 应该做的:**
- 使用 Pydantic V2 定义所有数据模型和配置
- 利用 Field() 函数提供额外验证规则和元数据
- 使用 Pydantic 的模型继承特性减少代码重复

**❌ 不应该做的:**
- 混用 Pydantic V1 和 V2 的特性
- 手动实现 Pydantic 已提供的验证功能
- 绕过 Pydantic 的类型检查和验证

## 特殊指令

1. **代码审查**: 在提交最终代码前，进行自我审查，检查潜在问题
2. **性能考虑**: 在处理与视频相关的功能时，特别注意性能影响
3. **错误处理**: 确保所有代码包含适当的错误处理机制
4. **向后兼容**: 确保更改不会破坏与 Android 客户端的兼容性
5. **系统依赖**: 充分利用 Debian Bookworm 系统自带的 GStreamer 1.22.0 版本
6. **测试覆盖**: 编写全面的单元测试和集成测试，使用 pytest-asyncio 测试异步代码

## Docker 容器化规范

1. **基础镜像**: 使用 Python 3.12 和 Debian Bookworm 作为基础镜像
2. **系统依赖**: 在 Dockerfile 中安装必要的系统依赖，特别是 GStreamer 相关包
3. **构建优化**: 优化 Docker 镜像大小和构建过程
4. **环境变量**: 使用环境变量进行配置，遵循 12 Factor App 原则
5. **持久化存储**: 使用 Docker 卷存储视频文件，确保数据持久性