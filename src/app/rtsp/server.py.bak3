"""
RTSP 服务器模块

该模块实现基于 GStreamer 的 RTSP 服务器，支持：
   - H.264 视频流处理和播放
   - RTSP 推流接收
   - 多客户端并发连接
   """

from ..core.logger import get_logger
from ..core.config import get_settings
from gi.repository import Gst, GstRtspServer, GstRtsp, GLib  # type: ignore
import os
import gi
import time
import threading
from datetime import datetime
from pathlib import Path
from typing import Optional, Dict, Any, Callable, cast

# 设置GStreamer版本
gi.require_version('Gst', '1.0')
gi.require_version('GstRtspServer', '1.0')
gi.require_version('GstRtsp', '1.0')

# 获取日志记录器
logger = get_logger(__name__)


class RtspServer:
    """RTSP 服务器类

    实现基于 GStreamer 的 RTSP 服务器，支持：
    - 播放端点 (/live)：提供测试视频源
    - 推流端点 (/push)：接收 RTSP 推流
    - 多客户端并发连接
    """

    def __init__(self):
        """初始化 RTSP 服务器"""
        self.settings = get_settings()
        self._init_gstreamer()

        # 服务器状态
        self._running = False
        self._clients: Dict[str, GstRtspServer.RTSPClient] = {}
        self._lock = threading.Lock()  # General lock for client list
        self.live_appsrc_lock = threading.Lock()  # Specific lock for live_appsrc

        # GStreamer 组件
        self.server: Optional[GstRtspServer.RTSPServer] = None
        self.play_factory: Optional[GstRtspServer.RTSPMediaFactory] = None
        self.push_factory: Optional[GstRtspServer.RTSPMediaFactory] = None
        self.mainloop: Optional[GLib.MainLoop] = None
        self.live_appsrc: Optional[Gst.Element] = None  # For /live endpoint

        logger.info("RTSP 服务器初始化完成")

    def _init_gstreamer(self) -> None:
        """初始化 GStreamer"""
        Gst.init(None)

    def _create_play_pipeline(self) -> str:
        """创建 /live 端点的 GStreamer 管道字符串"""
        # appsrc: Injects H264 buffers from the /push endpoint.
        # queue: Adds a buffer, decouples appsrc from downstream, leaky to prevent blocking.
        # h264parse: Parses H264 stream, extracts SPS/PPS, ensures AU alignment.
        # rtph264pay: Packetizes H264 into RTP packets for RTSP.
        return "appsrc name=live_h264_source ! queue leaky=downstream max-size-buffers=10 ! h264parse ! rtph264pay name=pay0 pt=96"

    def _create_push_pipeline(self) -> str:
        """创建推流端点的 GStreamer pipeline

        Returns:
            str: Pipeline 描述字符串
        """
        logger.info("创建 /push 推流端点管道 (rtph264depay ! h264parse ! appsink)")
        # This pipeline will output H264 data to an appsink
        pipeline = (
            "rtph264depay name=depay0 ! "
            "h264parse name=parse0 ! "
            "appsink name=push_appsink emit-signals=true"
        )
        logger.debug(f"/push 推流端点处理管道: {pipeline}")
        return pipeline

    def _setup_media_factories(self) -> None:
        """配置 RTSP MediaFactory"""
        # 创建播放端点的媒体工厂
        self.play_factory = GstRtspServer.RTSPMediaFactory()
        if self.play_factory is None:
            raise RuntimeError("无法创建播放端点 RTSPMediaFactory")

        # 配置播放端点
        play_pipeline = self._create_play_pipeline()
        self.play_factory.set_launch(play_pipeline)
        self.play_factory.set_shared(True)
        self.play_factory.set_latency(0)
        self.play_factory.set_eos_shutdown(True)
        self.play_factory.connect(
            'media-configure', self._on_play_media_configure)
        self.play_factory.connect(
            'media-constructed', self._on_media_constructed)

        # 创建推流端点的媒体工厂
        self.push_factory = GstRtspServer.RTSPMediaFactory()
        if self.push_factory is None:
            raise RuntimeError("无法创建推流端点 RTSPMediaFactory")

        # 配置推流端点
        push_pipeline = self._create_push_pipeline()
        self.push_factory.set_launch(push_pipeline)
        # self.push_factory.set_media_type(GstRtspServer.RTSPMediaType.APPLICATION)  # REMOVED due to AttributeError - User wants this, but it causes error.
        self.push_factory.set_transport_mode(
            # Changed to RECORD as per user's latest feedback
            GstRtspServer.RTSPTransportMode.RECORD)
        # Important for RECORD mode, each client gets its own media instance
        self.push_factory.set_shared(False)
        self.push_factory.set_latency(0)
        self.push_factory.set_eos_shutdown(False)

        # 为推流端点添加权限
        permissions = GstRtspServer.RTSPPermissions()
        # 允许匿名用户执行关键的推流操作
        permissions.add_permission_for_role(
            "anonymous", GstRtsp.RTSPMethod.ANNOUNCE.value_names[0], True)
        permissions.add_permission_for_role(
            "anonymous", GstRtsp.RTSPMethod.RECORD.value_names[0], True)
        permissions.add_permission_for_role(
            "anonymous", GstRtsp.RTSPMethod.SETUP.value_names[0], True)
        permissions.add_permission_for_role(
            "anonymous", GstRtsp.RTSPMethod.PLAY.value_names[0], True)
        permissions.add_permission_for_role(
            "anonymous", GstRtsp.RTSPMethod.GET_PARAMETER.value_names[0], True)
        permissions.add_permission_for_role(
            "anonymous", GstRtsp.RTSPMethod.SET_PARAMETER.value_names[0], True)
        permissions.add_permission_for_role(
            "anonymous", GstRtsp.RTSPMethod.TEARDOWN.value_names[0], True)
        permissions.add_permission_for_role(
            "anonymous", GstRtsp.RTSPMethod.OPTIONS.value_names[0], True)
        permissions.add_permission_for_role(
            "anonymous", GstRtsp.RTSPMethod.DESCRIBE.value_names[0], True)
        self.push_factory.set_permissions(permissions)
        logger.info("为推流端点 /push 设置了自定义权限")

        self.push_factory.connect(
            'media-configure', self._on_push_media_configure)
        self.push_factory.connect(
            'media-constructed', self._on_media_constructed)

        logger.debug("已配置 RTSP MediaFactory")

    def _on_media_constructed(self, factory: GstRtspServer.RTSPMediaFactory,
                              media: GstRtspServer.RTSPMedia) -> None:
        """媒体构建回调"""
        logger.info(f"媒体已构建 for factory: {factory}")  # Log which factory
        element = media.get_element()

        # 获取元素状态
        ret, state, pending = element.get_state(Gst.SECOND)
        logger.info(f"媒体构建后状态: {state.value_nick}, 待定状态: {pending.value_nick}")

    def _on_play_media_configure(self, factory: GstRtspServer.RTSPMediaFactory, media: GstRtspServer.RTSPMedia):
        """/live 客户端连接并配置媒体时的回调"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S,%f")[:-3]
        logger.info(
            f"[{timestamp}] _on_play_media_configure invoked for /live. Media: {media}, Factory: {factory}")
        pipeline = media.get_element()

        appsrc_configured_successfully = False
        with self.live_appsrc_lock:
            if pipeline:
                appsrc = pipeline.get_by_name("live_h264_source")
                if appsrc and isinstance(appsrc, Gst.Element) and hasattr(appsrc, 'set_property') and hasattr(appsrc, 'get_property'):
                    logger.info(
                        f"[{timestamp}] Successfully found 'live_h264_source'. Configuring its properties.")
                    caps = Gst.Caps.from_string(
                        "video/x-h264, stream-format=byte-stream, alignment=au")
                    appsrc.set_property("caps", caps)
                    appsrc.set_property("format", Gst.Format.TIME)
                    appsrc.set_property("is-live", True)
                    appsrc.set_property("max-bytes", 2 * 1024 * 1024)
                    appsrc.set_property("block", False)

                    # Log configured properties directly from appsrc
                    logger.info(
                        f"[{timestamp}] Configured live_h264_source properties: format={appsrc.get_property('format')}, "
                        f"is-live={appsrc.get_property('is-live')}, "
                        f"max-bytes={appsrc.get_property('max-bytes')}, "
                        f"block={appsrc.get_property('block')}, "
                        f"caps={appsrc.get_property('caps').to_string()}"
                    )
                    self.live_appsrc = appsrc  # Assign to self.live_appsrc after successful configuration
                    appsrc_configured_successfully = True
                    logger.info(
                        f"[{timestamp}] Assigned configured 'live_h264_source' to self.live_appsrc within lock.")
                else:
                    self.live_appsrc = None
                    logger.warning(
                        f"[{timestamp}] 'live_h264_source' not found, not a Gst.Element, or missing methods in /live pipeline. self.live_appsrc set to None within lock.")
            else:
                self.live_appsrc = None
                logger.warning(
                    f"[{timestamp}] Pipeline not available for /live media. self.live_appsrc set to None within lock.")

        final_live_appsrc_status = "ASSIGNED" if appsrc_configured_successfully else "None"
        logger.info(f"[{timestamp}] _on_play_media_configure finished for /live. self.live_appsrc is {final_live_appsrc_status} (status determined within lock, checked after lock release).")

        # Common media configuration (e.g., bus monitoring)
        self._configure_media(media, "Live endpoint (/live)")
        logger.info("Finished configuring /live media.")

    def _on_push_media_configure(self, factory: GstRtspServer.RTSPMediaFactory,
                                 media: GstRtspServer.RTSPMedia) -> None:
        """推流端点媒体配置回调"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S,%f")[:-3]
        logger.info(
            f"[{timestamp}] _on_push_media_configure invoked for /push. Media: {media}, Factory: {factory}")
        pipeline = media.get_element()
        if not pipeline:
            logger.error(
                f"[{timestamp}] Failed to get pipeline from media for /push.")
            return

        appsink = pipeline.get_by_name("push_appsink")
        if not appsink:
            logger.error(
                f"[{timestamp}] 'push_appsink' not found in /push pipeline.")
            return

        logger.info(
            f"[{timestamp}] Configuring /push appsink (push_appsink) properties.")
        appsink.set_property("emit-signals", True)
        appsink.set_property("max-buffers", 1)  # Process samples immediately
        # Don't drop samples if buffer is full
        appsink.set_property("drop", False)
        # Process buffers ASAP, don't sync to clock
        appsink.set_property("sync", False)

        # Connect the new-sample signal *once*
        # It's important to ensure no previous connections to this specific callback exist if this method can be called multiple times for the same media,
        # however, for RTSPMediaFactory, media-configure is typically called once per media object.
        # If there's a possibility of multiple connections, one might need to manage signal handler IDs.
        # For now, assuming a single appropriate connection.
        try:
            # Attempt to disconnect first, in case of re-configuration or to ensure clean state.
            # This might require storing the handler_id if precise management is needed.
            # For simplicity, we'll rely on GObject's behavior for multiple connections of the same callback (usually benign, but can lead to multiple calls).
            # A more robust way is to use handler_block/unblock or manage handler_ids.
            # However, let's assume connecting once here is the goal.
            # We will rely on the previous duplicate connection logic being removed.
            # No explicit disconnect without handler_id, relying on this being the sole configuration point.
            pass
        except TypeError:  # No signal connected with that name/callback
            pass

        appsink.connect("new-sample", self._on_new_sample_from_push)
        self.push_appsink = appsink  # Keep a reference

        logger.info(
            f"[{timestamp}] /push appsink (push_appsink) configured and 'new-sample' signal connected: "
            f"emit-signals={appsink.get_property('emit-signals')}, "
            f"max-buffers={appsink.get_property('max-buffers')}, "
            f"drop={appsink.get_property('drop')}, "
            f"sync={appsink.get_property('sync')}"
        )

        self._configure_media(media, "Push endpoint (/push)")
        logger.info(f"[{timestamp}] Finished configuring /push media.")

    def _on_new_sample_from_push(self, appsink: Gst.Element) -> Gst.FlowReturn:
        """从 /push 管道的 appsink 接收到新样本时的回调"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S,%f")[:-3]
        logger.debug(
            f"[{timestamp}] _on_new_sample_from_push invoked for appsink: {appsink.get_name()}")

        sample = appsink.emit("pull-sample")
        if not sample:
            logger.warning(
                f"[{timestamp}] push_appsink pull-sample did not return a sample. Appsink: {appsink.get_name()}. Returning FLUSHING.")
            return Gst.FlowReturn.FLUSHING

        logger.debug(
            f"[{timestamp}] push_appsink pull-sample returned a sample. Appsink: {appsink.get_name()}.")

        buffer = sample.get_buffer()
        if not buffer:
            logger.warning(
                f"[{timestamp}] push_appsink pull-sample returned a sample with no buffer. Appsink: {appsink.get_name()}. Returning ERROR.")
            return Gst.FlowReturn.ERROR

        buffer_size = buffer.get_size()  # Define buffer_size

        logger.debug(
            f"[{timestamp}] push_appsink sample has buffer of size {buffer_size}. Appsink: {appsink.get_name()}.")

        current_live_appsrc_local: Optional[Gst.Element] = None
        live_appsrc_name_for_log = "None"  # Default to "None"

        with self.live_appsrc_lock:
            current_live_appsrc_local = self.live_appsrc
            if current_live_appsrc_local:
                # Safely get name if object exists and is a Gst.Element
                try:
                    live_appsrc_name_for_log = current_live_appsrc_local.get_name()
                except AttributeError:
                    live_appsrc_name_for_log = "Unknown (not a Gst.Element?)"

        # Log immediately after lock release, using the captured name or "None"
        logger.debug(
            f"[{timestamp}] _on_new_sample_from_push: Checked self.live_appsrc. Found: '{live_appsrc_name_for_log}'. Buffer size: {buffer_size}.")

        if current_live_appsrc_local:
            # This is the block where we expect to push
            logger.debug(
                f"[{timestamp}] Attempting push to live_appsrc ('{live_appsrc_name_for_log}'). Current state of appsrc and its parent will be logged next.")

            live_appsrc_parent_pipeline = current_live_appsrc_local.get_parent()
            if not live_appsrc_parent_pipeline:
                logger.warning(
                    f"[{timestamp}] live_appsrc ('{live_appsrc_name_for_log}') does not have a parent pipeline. Cannot check state or push. Dropping buffer.")
                return Gst.FlowReturn.OK  # Or an appropriate error

            # Get states (returns a tuple: (Gst.StateChangeReturn, Gst.State, Gst.State))
            ret_state, live_appsrc_current_state, live_appsrc_pending_state = current_live_appsrc_local.get_state(
                Gst.CLOCK_TIME_NONE)
            ret_parent_state, live_appsrc_parent_current_state, live_appsrc_parent_pending_state = live_appsrc_parent_pipeline.get_state(
                Gst.CLOCK_TIME_NONE)

            live_appsrc_state_str = live_appsrc_current_state.value_nick
            live_appsrc_pending_state_str = live_appsrc_pending_state.value_nick
            live_appsrc_parent_pipeline_state_str = live_appsrc_parent_current_state.value_nick
            live_appsrc_parent_pending_state_str = live_appsrc_parent_pending_state.value_nick

            logger.debug(
                f"[{timestamp}] live_appsrc ('{live_appsrc_name_for_log}') state: {live_appsrc_state_str} (Pending: {live_appsrc_pending_state_str}). "
                f"Parent Pipeline ('{live_appsrc_parent_pipeline.get_name()}') State: {live_appsrc_parent_pipeline_state_str} (Pending: {live_appsrc_parent_pending_state_str}). Buffer size: {buffer_size}"
            )

            # Check if appsrc is in PLAYING state, if not, it might not accept data well.
            if current_live_appsrc_local.get_state(0)[1] != Gst.State.PLAYING:
                logger.warning(
                    f"[{timestamp}] live_appsrc ('{live_appsrc_name_for_log}') is not in PLAYING state (current: {live_appsrc_state_str}). Push might fail or be problematic.")

            ret = current_live_appsrc_local.emit("push-buffer", buffer)

            if ret == Gst.FlowReturn.OK:
                # Ensure this log is active
                logger.debug(
                    f"Successfully pushed buffer (size: {buffer_size}) to live_appsrc.")
                return Gst.FlowReturn.OK
            elif ret == Gst.FlowReturn.FLUSHING:
                logger.warning(
                    f"live_appsrc push-buffer returned FLUSHING. Buffer size: {buffer_size}. "
                    f"AppSrc State during push: {live_appsrc_state_str} (Pending: {live_appsrc_pending_state_str}). "
                    f"Parent Pipeline State during push: {live_appsrc_parent_pipeline_state_str} (Pending: {live_appsrc_parent_pending_state_str}). "
                    "Dropping buffer for /live, but keeping /push alive."
                )
                return Gst.FlowReturn.OK  # Keep /push alive
            else:
                logger.error(
                    f"live_appsrc push-buffer returned critical error: {ret.value_name if hasattr(ret, 'value_name') else ret}. Buffer size: {buffer_size}. "
                    f"AppSrc State during push: {live_appsrc_state_str} (Pending: {live_appsrc_pending_state_str}). "
                    f"Parent Pipeline State during push: {live_appsrc_parent_pipeline_state_str} (Pending: {live_appsrc_parent_pending_state_str}). "
                    "Propagating this status to push_appsink."
                )
                return ret
        else:
            logger.warning(
                f"[{timestamp}] live_appsrc not configured or available (checked within lock), dropping buffer (size: {buffer_size}) from appsink: {appsink.get_name()}. Returning OK.")
            return Gst.FlowReturn.OK

    def _configure_media(self, media: GstRtspServer.RTSPMedia, endpoint: str) -> None:
        """配置媒体元素

        Args:
            media: RTSP 媒体实例
            endpoint: 端点名称（用于日志）
        """
        element = media.get_element()

        # 配置总线监听
        bus = element.get_bus()
        if (bus):  # bus can be None if element is not a Gst.Bin or Gst.Pipeline
            bus.add_signal_watch()
            bus.connect('message', self._on_bus_message)
        else:
            logger.warning(f"Could not get bus for media element {endpoint}")

        # State management is now deferred to the GstRtspServer.RTSPMedia object itself.
        # No explicit element.set_state() here.
        logger.info(f"媒体元素 {endpoint} 已配置总线监听。状态将由 RTSP 服务器管理。")

    def _on_client_connected(self, server: GstRtspServer.RTSPServer,
                             client: GstRtspServer.RTSPClient) -> None:
        """客户端连接回调"""
        with self._lock:
            client_id = str(id(client))
            self._clients[client_id] = client
            logger.info(f"客户端连接: {client_id}")

        client.connect('closed', self._on_client_disconnected)

    def _on_client_disconnected(self, client: GstRtspServer.RTSPClient) -> None:
        """客户端断开回调"""
        with self._lock:
            client_id = str(id(client))
            if client_id in self._clients:
                del self._clients[client_id]
                logger.info(f"客户端断开: {client_id}")

    def _on_bus_message(self, bus: Gst.Bus, message: Gst.Message) -> None:
        """处理管道总线消息"""
        t = message.type
        if t == Gst.MessageType.ERROR:
            err, debug = message.parse_error()
            logger.error(
                f"GStreamer错误 from {message.src.get_path_string() if message.src else 'Unknown Source'}: {err.message}")
            logger.debug(f"调试信息: {debug}")
        elif t == Gst.MessageType.WARNING:
            warn, debug = message.parse_warning()
            logger.warning(
                f"GStreamer警告 from {message.src.get_path_string() if message.src else 'Unknown Source'}: {warn.message}")
            logger.debug(f"调试信息: {debug}")
        elif t == Gst.MessageType.STATE_CHANGED:
            if message.src and isinstance(message.src, Gst.Element):
                old_state, new_state, pending_state = message.parse_state_changed()
                logger.info(
                    f"状态变化 on {message.src.get_name()}: {old_state.value_nick} -> {new_state.value_nick} (待定: {pending_state.value_nick})"
                )
            else:
                logger.info("状态变化 on non-element source")
        elif t == Gst.MessageType.EOS:
            logger.info(
                f"收到流结束信号 from {message.src.get_path_string() if message.src else 'Unknown Source'}")

    def start(self) -> None:
        """启动 RTSP 服务器"""
        if self._running:
            logger.warning("服务器已在运行")
            return

        try:
            self.server = cast(GstRtspServer.RTSPServer,
                               GstRtspServer.RTSPServer.new())
            if self.server is None:
                raise RuntimeError("无法创建 RTSP 服务器")

            self.server.set_service(str(self.settings.RTSP_PORT))
            self._setup_media_factories()
            mount_points = self.server.get_mount_points()
            if mount_points is None:
                raise RuntimeError("无法获取挂载点")

            mount_points.add_factory(
                "/live", cast(GstRtspServer.RTSPMediaFactory, self.play_factory))
            mount_points.add_factory(
                "/push", cast(GstRtspServer.RTSPMediaFactory, self.push_factory))
            self.server.connect('client-connected', self._on_client_connected)
            self.server.attach(None)
            logger.info(
                f"RTSP 服务器启动:\n"
                f"- 播放地址: rtsp://0.0.0.0:{self.settings.RTSP_PORT}/live\n"
                f"- 推流地址: rtsp://0.0.0.0:{self.settings.RTSP_PORT}/push\n"
            )

            self._running = True
            self.mainloop = GLib.MainLoop()
            if self.mainloop is None:
                raise RuntimeError("无法创建主循环")

            self._mainloop_thread = threading.Thread(
                target=self.mainloop.run, daemon=True)
            self._mainloop_thread.start()
            time.sleep(1)

        except Exception as e:
            logger.error(f"启动 RTSP 服务器失败: {str(e)}")
            self.stop()
            raise

    def stop(self) -> None:
        """停止 RTSP 服务器"""
        if not self._running:
            return

        try:
            with self._lock:
                # Iterate over a copy of keys
                for client_id in list(self._clients.keys()):
                    client = self._clients.pop(client_id, None)
                    # client.finalize() # This might be too aggressive or cause issues if client is already closing
                    logger.info(f"清理客户端: {client_id}")

            if self.mainloop and self.mainloop.is_running():
                self.mainloop.quit()

            # Wait for mainloop thread to finish if it was started
            if hasattr(self, '_mainloop_thread') and self._mainloop_thread.is_alive():
                self._mainloop_thread.join(timeout=2)  # Wait for 2 seconds
                if self._mainloop_thread.is_alive():
                    logger.warning("Mainloop thread did not exit gracefully.")

            # Detach server from context to release resources
            if self.server:
                self.server.detach()
                # According to some GStreamer docs/examples, setting server to None might help with cleanup
                # self.server = None

            self._running = False
            logger.info("RTSP 服务器已停止")

        except Exception as e:
            logger.error(f"停止 RTSP 服务器时出错: {str(e)}")
            # Do not re-raise here as it might suppress the original exception if stopping during an exception

    @property
    def is_running(self) -> bool:
        """获取服务器运行状态"""
        return self._running

    def get_client_count(self) -> int:
        """获取当前连接的客户端数量"""
        with self._lock:
            return len(self._clients)

    def __enter__(self) -> 'RtspServer':
        """上下文管理器入口"""
        self.start()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        """上下文管理器出口"""
        self.stop()
